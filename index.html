<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Block Blast Pastel Edition</title>
    <style>
        :root {
            --bg-color: #f5f5fa;
            --grid-color: #e0e0e6;
            --heart-color: #ff6478;
        }
        body {
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Malgun Gothic', sans-serif;
            overflow: hidden;
        }
        #ui-container {
            text-align: center;
            margin-bottom: 20px;
        }
        #heart-icon {
            font-size: 40px;
            color: var(--heart-color);
            display: inline-block;
            transition: transform 0.1s;
        }
        .beating {
            animation: beat 0.4s ease-out;
        }
        @keyframes beat {
            0% { transform: scale(1); }
            50% { transform: scale(1.4); }
            100% { transform: scale(1); }
        }
        #score {
            font-size: 32px;
            font-weight: bold;
            color: #505064;
            margin-top: 5px;
        }
        canvas {
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <div id="heart-icon">❤️</div>
        <div id="score">0</div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const heartIcon = document.getElementById('heart-icon');

        const GRID_SIZE = 8;
        const CELL_SIZE = 45;
        canvas.width = GRID_SIZE * CELL_SIZE;
        canvas.height = GRID_SIZE * CELL_SIZE;

        let score = 0;
        let board = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
        let particles = [];

        const PASTEL_COLORS = [
            { base: '#FFB7B2', light: '#FFD1CF', shadow: '#E5A4A0' }, // 핑크
            { base: '#FFDAC1', light: '#FFEBDC', shadow: '#E5C4AE' }, // 오렌지
            { base: '#E2F0CB', light: '#EFF7E0', shadow: '#CBD8B6' }, // 그린
            { base: '#B5EAD7', light: '#D2F3E8', shadow: '#A2D2C1' }, // 민트
            { base: '#C7CEEA', light: '#E1E5F4', shadow: '#B3B9D2' }  // 퍼플
        ];

        function draw3DBlock(x, y, colorIdx) {
            const color = PASTEL_COLORS[colorIdx];
            const r = 6; // 둥근 모서리

            // 그림자/바닥
            ctx.fillStyle = color.shadow;
            fillRoundRect(x, y, CELL_SIZE, CELL_SIZE, r);

            // 메인 면
            ctx.fillStyle = color.base;
            fillRoundRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 6, r);

            // 하이라이트
            ctx.strokeStyle = color.light;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + 8, y + 5);
            ctx.lineTo(x + CELL_SIZE - 8, y + 5);
            ctx.stroke();
        }

        function fillRoundRect(x, y, w, h, r) {
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, r);
            ctx.fill();
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const x = c * CELL_SIZE;
                    const y = r * CELL_SIZE;

                    // 격자 그리기
                    ctx.strokeStyle = '#e0e0e6';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, CELL_SIZE, CELL_SIZE);

                    if (board[r][c] > 0) {
                        draw3DBlock(x, y, board[r][c] - 1);
                    }
                }
            }
        }

        function createParticles(r, c, colorIdx) {
            for (let i = 0; i < 6; i++) {
                particles.push({
                    x: c * CELL_SIZE + CELL_SIZE / 2,
                    y: r * CELL_SIZE + CELL_SIZE / 2,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    color: PASTEL_COLORS[colorIdx].base,
                    life: 1.0
                });
            }
        }

        function checkLines() {
            let rowsToClear = [];
            let colsToClear = [];

            for (let r = 0; r < GRID_SIZE; r++) {
                if (board[r].every(cell => cell > 0)) rowsToClear.push(r);
            }
            for (let c = 0; c < GRID_SIZE; c++) {
                let colFull = true;
                for (let r = 0; r < GRID_SIZE; r++) {
                    if (board[r][c] === 0) colFull = false;
                }
                if (colFull) colsToClear.push(c);
            }

            if (rowsToClear.length > 0 || colsToClear.length > 0) {
                // 하트 애니메이션 재생
                heartIcon.classList.remove('beating');
                void heartIcon.offsetWidth; // 리플로우 강제
                heartIcon.classList.add('beating');

                rowsToClear.forEach(r => {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        createParticles(r, c, board[r][c] - 1);
                        board[r][c] = 0;
                    }
                });
                colsToClear.forEach(c => {
                    for (let r = 0; r < GRID_SIZE; r++) {
                        if (board[r][c] > 0) {
                            createParticles(r, c, board[r][c] - 1);
                            board[r][c] = 0;
                        }
                    }
                });

                score += (rowsToClear.length + colsToClear.length) * 100;
                scoreElement.innerText = score;
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const c = Math.floor(x / CELL_SIZE);
            const r = Math.floor(y / CELL_SIZE);

            if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {
                if (board[r][c] === 0) {
                    board[r][c] = Math.floor(Math.random() * PASTEL_COLORS.length) + 1;
                    checkLines();
                }
            }
        });

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1.0;
        }

        function gameLoop() {
            drawBoard();
            updateParticles();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
