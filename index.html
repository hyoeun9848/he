<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Perfect Block Blast</title>
    <style>
        body {
            background-color: #f8f9fa;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: sans-serif;
            overflow: hidden;
            user-select: none;
        }
        #score-container { text-align: center; margin-bottom: 15px; }
        #heart { font-size: 40px; color: #ff4d6d; display: inline-block; transition: transform 0.2s; }
        .beating { transform: scale(1.4); }
        #score { font-size: 45px; font-weight: bold; color: #333; margin: 5px 0; }
        canvas { 
            background: #fff; 
            border-radius: 15px; 
            box-shadow: 0 15px 35px rgba(0,0,0,0.1); 
            touch-action: none;
        }
    </style>
</head>
<body>

    <div id="score-container">
        <div id="heart">❤️</div>
        <div id="score">0</div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const heartEl = document.getElementById('heart');

const GRID_SIZE = 8;
const CELL_SIZE = 48; // 칸 크기 확대
const BOARD_OFFSET = 20;
const BOTTOM_HEIGHT = 180;

canvas.width = (GRID_SIZE * CELL_SIZE) + (BOARD_OFFSET * 2);
canvas.height = canvas.width + BOTTOM_HEIGHT;

const COLORS = [
    { b: '#FFB7B2', l: '#FFD1CF', s: '#E5A4A0' }, // 핑크
    { b: '#FFDAC1', l: '#FFEBDC', s: '#E5C4AE' }, // 오렌지
    { b: '#E2F0CB', l: '#EFF7E0', s: '#CBD8B6' }, // 그린
    { b: '#B5EAD7', l: '#D2F3E8', s: '#A2D2C1' }, // 민트
    { b: '#C7CEEA', l: '#E1E5F4', s: '#B3B9D2' }  // 퍼플
];

const SHAPES = [
    [[1,1],[1,1]], [[1,1,1,1]], [[1],[1],[1],[1]], 
    [[1,1,1],[0,1,0]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1]]
];

let board = Array.from({length: GRID_SIZE}, () => Array(GRID_SIZE).fill(null));
let hand = [];
let score = 0;
let draggingBlock = null;
let mouseX = 0, mouseY = 0;

function createHand() {
    hand = [];
    for(let i=0; i<3; i++) {
        const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
        const colorIdx = Math.floor(Math.random() * COLORS.length);
        hand.push({
            shape, colorIdx,
            x: 40 + i * 130,
            y: canvas.width + 40,
            origX: 40 + i * 130,
            origY: canvas.width + 40,
            w: shape[0].length * CELL_SIZE * 0.7,
            h: shape.length * CELL_SIZE * 0.7
        });
    }
}

function drawBlock(context, shape, x, y, colorIdx, scale = 1) {
    const size = CELL_SIZE * scale;
    const color = COLORS[colorIdx];
    shape.forEach((row, r) => {
        row.forEach((cell, c) => {
            if(cell) {
                const bx = x + c * size;
                const by = y + r * size;
                context.fillStyle = color.s;
                context.beginPath(); context.roundRect(bx, by, size, size, 5); context.fill();
                context.fillStyle = color.b;
                context.beginPath(); context.roundRect(bx+2, by+2, size-4, size-6, 5); context.fill();
                context.strokeStyle = color.l; context.lineWidth = 2;
                context.strokeRect(bx+6, by+4, size-12, 1);
            }
        });
    });
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 1. 보드 배경 및 배치된 블록
    for(let r=0; r<GRID_SIZE; r++) {
        for(let c=0; c<GRID_SIZE; c++) {
            ctx.fillStyle = '#f0f0f5';
            ctx.beginPath();
            ctx.roundRect(BOARD_OFFSET + c*CELL_SIZE, BOARD_OFFSET + r*CELL_SIZE, CELL_SIZE-3, CELL_SIZE-3, 5);
            ctx.fill();
            if(board[r][c] !== null) {
                drawBlock(ctx, [[1]], BOARD_OFFSET + c*CELL_SIZE, BOARD_OFFSET + r*CELL_SIZE, board[r][c], 1);
            }
        }
    }

    // 2. 하단 블록들
    hand.forEach(b => {
        if(b !== draggingBlock) drawBlock(ctx, b.shape, b.x, b.y, b.colorIdx, 0.7);
    });

    // 3. 드래그 중인 블록 (마우스 따라다님)
    if(draggingBlock) {
        drawBlock(ctx, draggingBlock.shape, mouseX - draggingBlock.w/2, mouseY - draggingBlock.h/2, draggingBlock.colorIdx, 1);
    }

    requestAnimationFrame(render);
}

// 이벤트 리스너
canvas.addEventListener('mousedown', e => {
    const r = canvas.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;

    hand.forEach(b => {
        if(mx > b.x && mx < b.x + b.w && my > b.y && my < b.y + b.h) {
            draggingBlock = b;
        }
    });
});

window.addEventListener('mousemove', e => {
    const r = canvas.getBoundingClientRect();
    mouseX = e.clientX - r.left;
    mouseY = e.clientY - r.top;
});

window.addEventListener('mouseup', () => {
    if(!draggingBlock) return;

    // 보드 위치 계산 (블록의 왼쪽 상단 기준)
    const gridX = Math.round((mouseX - draggingBlock.w/2 - BOARD_OFFSET) / CELL_SIZE);
    const gridY = Math.round((mouseY - draggingBlock.h/2 - BOARD_OFFSET) / CELL_SIZE);

    if(canPlace(draggingBlock.shape, gridY, gridX)) {
        placeBlock(draggingBlock.shape, gridY, gridX, draggingBlock.colorIdx);
        hand = hand.filter(b => b !== draggingBlock);
        if(hand.length === 0) createHand();
        checkLines();
    }
    
    draggingBlock = null;
});

function canPlace(shape, row, col) {
    for(let r=0; r<shape.length; r++) {
        for(let c=0; c<shape[r].length; c++) {
            if(shape[r][c]) {
                let nr = row + r, nc = col + c;
                if(nr < 0 || nr >= GRID_SIZE || nc < 0 || nc >= GRID_SIZE || board[nr][nc] !== null) return false;
            }
        }
    }
    return true;
}

function placeBlock(shape, row, col, colorIdx) {
    shape.forEach((rArr, r) => {
        rArr.forEach((cell, c) => {
            if(cell) board[row+r][col+c] = colorIdx;
        });
    });
    score += 10; // 블록 배치 점수
    updateScore();
}

function checkLines() {
    let rToClear = [], cToClear = [];
    for(let r=0; r<GRID_SIZE; r++) if(board[r].every(v => v !== null)) rToClear.push(r);
    for(let c=0; c<GRID_SIZE; c++) {
        let full = true;
        for(let r=0; r<GRID_SIZE; r++) if(board[r][c] === null) full = false;
        if(full) cToClear.push(c);
    }

    if(rToClear.length || cToClear.length) {
        rToClear.forEach(r => board[r].fill(null));
        cToClear.forEach(c => { for(let r=0; r<GRID_SIZE; r++) board[r][c] = null; });
        score += (rToClear.length + cToClear.length) * 100;
        updateScore();
        heartBeat();
    }
}

function updateScore() { scoreEl.innerText = score; }
function heartBeat() {
    heartEl.classList.add('beating');
    setTimeout(() => heartEl.classList.remove('beating'), 300);
}

createHand();
render();
</script>
</body>
</html>
